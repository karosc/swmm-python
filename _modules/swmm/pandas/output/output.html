
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="red">
  <script src="../../../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>swmm.pandas.output.output &#8212; swmm-pandas</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/material.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.png"/>
    <link rel="search" title="Search" href="../../../../search.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=indigo data-md-color-accent=blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/swmm/pandas/output/output" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../../../index.html" title="swmm-pandas"
           class="md-header-nav__button md-logo">
          
              <img src="../../../../_static/favicon.png" height="26"
                   alt="swmm-pandas logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">swmm-pandas 0.1.0</span>
          <span class="md-header-nav__topic"> swmm.pandas.output.output </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../../../search.html" method="get" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/karosc/swmm-pandas/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    swmm-pandas
  </div>
</a>
          </div>
        </div>
      
      
  
  <script src="../../../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../../../"versions.json"",
        target_loc = "../../../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../../../index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../../../index.html" title="swmm-pandas" class="md-nav__button md-logo">
      
        <img src="../../../../_static/favicon.png" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../../../../index.html"
       title="swmm-pandas">swmm-pandas 0.1.0</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/karosc/swmm-pandas/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    swmm-pandas
  </div>
</a>
    </div>
  
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
    
      <a href="../../../../installation.html" class="md-nav__link">Installation</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../usage.html" class="md-nav__link">Usage</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../reference/index.html" class="md-nav__link">API Reference</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
    

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-swmm-pandas-output-output--page-root">Source code for swmm.pandas.output.output</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">aenum</span> <span class="kn">import</span> <span class="n">EnumMeta</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">NoReturn</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">aenum</span> <span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">extend_enum</span>
<span class="kn">from</span> <span class="nn">julian</span> <span class="kn">import</span> <span class="n">from_jd</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">atleast_1d</span><span class="p">,</span> <span class="n">atleast_2d</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">datetime64</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">integer</span> <span class="k">as</span> <span class="n">npint</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">tile</span><span class="p">,</span> <span class="n">vstack</span>
<span class="kn">from</span> <span class="nn">pandas.core.api</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">DatetimeIndex</span><span class="p">,</span>
    <span class="n">Index</span><span class="p">,</span>
    <span class="n">MultiIndex</span><span class="p">,</span>
    <span class="n">Timestamp</span><span class="p">,</span>
    <span class="n">to_datetime</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">swmm.toolkit</span> <span class="kn">import</span> <span class="n">output</span><span class="p">,</span> <span class="n">shared_enum</span>

<span class="kn">from</span> <span class="nn">swmm.pandas.output.structure</span> <span class="kn">import</span> <span class="n">Structure</span>
<span class="kn">from</span> <span class="nn">swmm.pandas.output.tools</span> <span class="kn">import</span> <span class="n">arrayish</span><span class="p">,</span> <span class="n">_enum_get</span><span class="p">,</span> <span class="n">_enum_keys</span>


<span class="k">def</span> <span class="nf">output_open_handler</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">"""Checks if output file is open before running function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        method of Output class</span>
<span class="sd">    """</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">inner_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">inner_function</span>


<div class="viewcode-block" id="Output"><a class="viewcode-back" href="../../../../reference/output/index.html#swmm.pandas.Output">[docs]</a><span class="k">class</span> <span class="nc">Output</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binfile</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">"""Base class for a SWMM binary output file.</span>

<span class="sd">        The output object provides several options to process timeseries within binary output file.</span>

<span class="sd">        Output files should be closed after use prevent memory leaks. Close them explicitly with</span>
<span class="sd">        the `_close()` method or deleting the object using `del`, or use it with a context manager.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Using a the _close method</span>
<span class="sd">            &gt;&gt;&gt; from swmm.pandas import Output</span>
<span class="sd">            &gt;&gt;&gt; out = Output('tests/Model.out')</span>
<span class="sd">            &gt;&gt;&gt; print(out.project_size)</span>
<span class="sd">            [3, 9, 8, 1, 3]</span>
<span class="sd">            &gt;&gt;&gt; out._close() # can also use `del out`</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            # Using a context manager</span>
<span class="sd">            &gt;&gt;&gt; with Output('tests/Model.out') as out:</span>
<span class="sd">            ...     print(out.pollutants)</span>
<span class="sd">            ('groundwater', 'pol_rainfall', 'sewage')</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        binfile : str</span>
<span class="sd">            model binary file path</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_period</span><span class="p">:</span> <span class="nb">int</span>
        <span class="sd">"""number of reporting time steps in the """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_report</span><span class="p">:</span> <span class="nb">int</span>
        <span class="sd">"""out file reporting time step in seconds"""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">:</span> <span class="n">datetime</span>
        <span class="sd">"""start datetime of the output file records"""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">:</span> <span class="n">datetime</span>
        <span class="sd">"""end datetime of the output file records"""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_timeIndex</span><span class="p">:</span> <span class="n">DatetimeIndex</span>
        <span class="sd">"""DatetimeIndex to use for output timeseries"""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_project_size</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
        <span class="sd">"""Array of element count values [nSubcatchments, nNodes, nLinks, nSystems(1), nPollutants]"""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_subcatchments</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="sd">"""Tuple of subcatchment names in output file"""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_links</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="sd">"""Tuple of link names in output file"""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pollutants</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="sd">"""Tuple of pollutant names in output file"""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_binfile</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">binfile</span>
        <span class="sd">"""path to binary output file"""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_delete_handle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">"""Indicates if output file was closed correctly"""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_loaded</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">"""Indicates if output file was loaded correctly"""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">subcatch_attributes</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span>
            <span class="s2">"subcatch_attributes"</span><span class="p">,</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">shared_enum</span><span class="o">.</span><span class="n">SubcatchAttribute</span><span class="o">.</span><span class="n">__members__</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="sd">"""Subcatchment attribute enumeration: By default has</span>

<span class="sd">        'rainfall',</span>
<span class="sd">        'snow_depth',</span>
<span class="sd">        'evap_loss',</span>
<span class="sd">        'infil_loss',</span>
<span class="sd">        'runoff_rate',</span>
<span class="sd">        'gw_outflow_rate',</span>
<span class="sd">        'gw_table_elev',</span>
<span class="sd">        'soil_moisture'</span>
<span class="sd">        """</span>

        <span class="c1"># need copies of enumes to extend them for pollutants</span>
        <span class="c1"># basically recreate enums using the keys from shared_enum</span>
        <span class="c1"># but drop POLLUT_CONC_0 for each</span>
        <span class="c1">#</span>
        <span class="c1"># I looked into using swmm.toolkit.output_metadata for this but it</span>
        <span class="c1"># extends global enums, which could break having multiple</span>
        <span class="c1"># output objects opened in the same python session if they</span>
        <span class="c1"># have different pollutant names</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span>
            <span class="s2">"node_attributes"</span><span class="p">,</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">shared_enum</span><span class="o">.</span><span class="n">NodeAttribute</span><span class="o">.</span><span class="n">__members__</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="sd">"""Node attribute enumeration: By default has</span>

<span class="sd">        'invert_depth',</span>
<span class="sd">        'hydraulic_head',</span>
<span class="sd">        'ponded_volume',</span>
<span class="sd">        'lateral_inflow',</span>
<span class="sd">        'total_inflow',</span>
<span class="sd">        'flooding_losses'</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">link_attributes</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span>
            <span class="s2">"link_attributes"</span><span class="p">,</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">shared_enum</span><span class="o">.</span><span class="n">LinkAttribute</span><span class="o">.</span><span class="n">__members__</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="sd">"""Link attribute enumeration: By default has</span>

<span class="sd">        'flow_rate',</span>
<span class="sd">        'flow_depth',</span>
<span class="sd">        'flow_velocity',</span>
<span class="sd">        'flow_volume',</span>
<span class="sd">        'capacity',</span>

<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">system_attributes</span> <span class="o">=</span> <span class="n">shared_enum</span><span class="o">.</span><span class="n">SystemAttribute</span>
        <span class="sd">"""System attribute enumeration: By default has</span>

<span class="sd">        'air_temp',</span>
<span class="sd">        'rainfall',</span>
<span class="sd">        'snow_depth',</span>
<span class="sd">        'evap_infil_loss',</span>
<span class="sd">        'runoff_flow',</span>
<span class="sd">        'dry_weather_inflow',</span>
<span class="sd">        'gw_inflow',</span>
<span class="sd">        'rdii_inflow',</span>
<span class="sd">        'direct_inflow',</span>
<span class="sd">        'total_lateral_inflow',</span>
<span class="sd">        'flood_losses',</span>
<span class="sd">        'outfall_flows',</span>
<span class="sd">        'volume_stored',</span>
<span class="sd">        'evap_rate',</span>
<span class="sd">        'ptnl_evap_rate'</span>

<span class="sd">        """</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_elementIndex</span><span class="p">(</span>
        <span class="n">elementID</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">indexSquence</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">elementType</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">"""Validate the index of a model element passed to Output methods. Used to</span>
<span class="sd">        convert model element names to their index in the out file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elementID : str, int</span>
<span class="sd">            The name or index of the model element listed in the index_dict dict.</span>
<span class="sd">        indexSquence : one of more string</span>
<span class="sd">            The ordered sequence against which to validate the index</span>
<span class="sd">            (one of self.nodes, self.links, self.subcatchments).</span>
<span class="sd">        elementType : str</span>
<span class="sd">            The type of model element (e.g. node, link, etc.)</span>
<span class="sd">            Only used to print the exception if an attribute cannot be found.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The integer index of the requested element.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        OutputException</span>
<span class="sd">            Exception if element cannot be found in indexSequence.</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elementID</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">npint</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">elementID</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">indexSquence</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">elementID</span><span class="p">)</span>

        <span class="c1"># since this class can pull multiple attributes and elements in one function</span>
        <span class="c1"># call it is probably better to do some pre-validation of input arguments</span>
        <span class="c1"># before starting a potentially lengthy data pull</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">elementType</span><span class="si">}</span><span class="s2"> ID: </span><span class="si">{</span><span class="n">elementID</span><span class="si">}</span><span class="s2"> does not exist in model output."</span>
            <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validateAttribute</span><span class="p">(</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">validAttributes</span><span class="p">:</span> <span class="n">Enum</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
        <span class="sd">"""</span>
<span class="sd">        Function to validate attribute arguments of element_series, element_attribute,</span>
<span class="sd">        and element_result functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute : Union[int, str, Sequence[Union[int, str]], None]</span>
<span class="sd">            The attribute to validate against validAttributes.</span>
<span class="sd">        validAttributes : dict</span>
<span class="sd">            THe dict of attributes against which to validate attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[list, list]</span>
<span class="sd">            Two arrays, one of attribute names and one of attribute indicies.</span>

<span class="sd">        """</span>
        <span class="c1"># this kind of logic was needed in the series and results functions.</span>
        <span class="c1"># not sure if this is the best way, but it felt a bit DRYer to</span>
        <span class="c1"># put it into a funciton</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">EnumMeta</span><span class="p">)):</span>
            <span class="n">attributeArray</span> <span class="o">=</span> <span class="n">_enum_keys</span><span class="p">(</span><span class="n">validAttributes</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">arrayish</span><span class="p">):</span>
            <span class="n">attributeArray</span> <span class="o">=</span> <span class="n">attribute</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attributeArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">attribute</span><span class="p">]</span>

        <span class="c1"># allow mixed input of attributes</span>
        <span class="c1"># accept string names, integers, or enums values in the same list</span>
        <span class="n">attributeIndexArray</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">attributeArray</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrib</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
                <span class="n">attributeArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">attributeIndexArray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attrib</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrib</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">npint</span><span class="p">)):</span>
                <span class="c1"># will raise index error if not in range</span>
                <span class="n">attribName</span> <span class="o">=</span> <span class="n">_enum_keys</span><span class="p">(</span><span class="n">validAttributes</span><span class="p">)[</span><span class="n">attrib</span><span class="p">]</span>
                <span class="n">attributeArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">attribName</span>
                <span class="n">attributeIndexArray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_enum_get</span><span class="p">(</span><span class="n">validAttributes</span><span class="p">,</span> <span class="n">attribName</span><span class="p">))</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrib</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">_enum_get</span><span class="p">(</span><span class="n">validAttributes</span><span class="p">,</span> <span class="n">attrib</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">"Attribute </span><span class="si">{</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> not in valid attribute list: </span><span class="si">{</span><span class="n">_enum_keys</span><span class="p">(</span><span class="n">validAttributes</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
                    <span class="p">)</span>
                <span class="n">attributeIndexArray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"Input type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">attrib</span><span class="p">)</span><span class="si">}</span><span class="s2"> not valid. Must be one of int, str, or Enum"</span>
                <span class="p">)</span>

        <span class="c1"># attributeIndexArray = [validAttributes.get(atr, -1) for atr in attributeArray]</span>

        <span class="k">return</span> <span class="n">attributeArray</span><span class="p">,</span> <span class="n">attributeIndexArray</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validateElement</span><span class="p">(</span>
        <span class="n">element</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">validElements</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">"""</span>
<span class="sd">        Function to validate element arguments of element_series, element_attribute,</span>
<span class="sd">        and element_result functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        element : Union[int, str, Sequence[Union[int, str]], None]</span>
<span class="sd">            The element name or index or None. If None, return all elements in</span>
<span class="sd">            validElements.</span>
<span class="sd">        validElements : Sequence[str]</span>
<span class="sd">            Tuple of elements against which to validate element.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[list, list]</span>
<span class="sd">            Two arrays, one of element names and one of element indicies.</span>

<span class="sd">        """</span>
        <span class="c1"># this kind of logic was needed in the series and results functions</span>
        <span class="c1"># not sure if this is the best way, but it felt a bit DRYer to</span>
        <span class="c1"># put it into a funciton</span>

        <span class="k">if</span> <span class="n">element</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elementArray</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">validElements</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">arrayish</span><span class="p">):</span>
            <span class="n">elementArray</span> <span class="o">=</span> <span class="n">element</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ignore typing since types of this output list</span>
            <span class="c1"># are reconciled in the next loop. mypy was complaining.</span>
            <span class="n">elementArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">element</span><span class="p">]</span>  <span class="c1"># type: ignore</span>

        <span class="n">elementIndexArray</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># allow mixed input of elements. string names can be mixed</span>
        <span class="c1"># with integer indicies in the same input list</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elementArray</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">npint</span><span class="p">)):</span>
                <span class="c1"># will raise index error if not in range</span>
                <span class="n">elemName</span> <span class="o">=</span> <span class="n">validElements</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
                <span class="n">elementArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">elemName</span>
                <span class="n">elementIndexArray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">elementIndexArray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Output</span><span class="o">.</span><span class="n">_elementIndex</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">validElements</span><span class="p">,</span> <span class="s2">""</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"Input type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="si">}</span><span class="s2"> not valid. Must be one of int, str"</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">elementArray</span><span class="p">,</span> <span class="n">elementIndexArray</span>

    <span class="k">def</span> <span class="nf">_checkPollutantName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">"""Check pollutant name against existing attribute dicts.</span>
<span class="sd">        Rename and and warn if existing attribute is duplicated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of pollutant.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The validated name of pollutant.</span>
<span class="sd">        """</span>

        <span class="n">elems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">_enum_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subcatch_attributes</span><span class="p">):</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"subcatchment"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">_enum_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">):</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"node"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">_enum_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link_attributes</span><span class="p">):</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"link"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">_enum_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">system_attributes</span><span class="p">):</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"system"</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">"Pollutent </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is a duplicate of existing </span><span class="si">{</span><span class="s1">','</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span><span class="si">}</span><span class="s2"> attribute, renaming to pol_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">"pol_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span>

        <span class="k">return</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">_open</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">"""Open a binary file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if binary file was opened successfully.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_binfile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Output file at: '</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_binfile</span><span class="si">}</span><span class="s2">' does not exist"</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loaded</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_loaded</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">output</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binfile</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">from_jd</span><span class="p">(</span>
                <span class="n">output</span><span class="o">.</span><span class="n">get_start_date</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2415018.5</span>
            <span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">microsecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_report</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">get_times</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">shared_enum</span><span class="o">.</span><span class="n">Time</span><span class="o">.</span><span class="n">REPORT_STEP</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_period</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">get_times</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">shared_enum</span><span class="o">.</span><span class="n">Time</span><span class="o">.</span><span class="n">NUM_PERIODS</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_period</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_report</span><span class="p">)</span>

            <span class="c1"># load pollutants if not already loaded</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"_pollutants"</span><span class="p">):</span>
                <span class="c1"># load pollutant data if it has not before</span>
                <span class="n">total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_size</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pollutants</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_checkPollutantName</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_objectName</span><span class="p">(</span><span class="n">shared_enum</span><span class="o">.</span><span class="n">ElementType</span><span class="o">.</span><span class="n">POLLUT</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pollutants</span><span class="p">):</span>
                    <span class="c1"># extend enums to include pollutants</span>
                    <span class="n">extend_enum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subcatch_attributes</span><span class="p">,</span> <span class="n">nom</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">extend_enum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">,</span> <span class="n">nom</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">extend_enum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link_attributes</span><span class="p">,</span> <span class="n">nom</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">"""Close an opened binary file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if binary file was closed successfully.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loaded</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete_handle</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1">###### outfile property getters ######</span>

    <span class="nd">@property</span>  <span class="c1"># type: ignore</span>
    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">"""Return the reporting timestep in seconds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The reporting timestep in seconds.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_report</span>

    <span class="nd">@property</span>  <span class="c1"># type: ignore</span>
    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
        <span class="sd">"""Return the reporting start datetime.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        datetime</span>
<span class="sd">            The reporting start datetime.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>

    <span class="nd">@property</span>  <span class="c1"># type: ignore</span>
    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
        <span class="sd">"""Return the reporting end datetime.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        datetime</span>
<span class="sd">            The reporting end datetime.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span>

    <span class="nd">@property</span>  <span class="c1"># type: ignore</span>
    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">period</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">"""Return the number of reporting timesteps in the binary output file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of reporting timesteps.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_period</span>

    <span class="nd">@property</span>  <span class="c1"># type: ignore</span>
    <span class="k">def</span> <span class="nf">project_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">"""Returns the number of each model element type available in out binary output file</span>
<span class="sd">        in the following order:</span>

<span class="sd">        [subcatchment, node, link, system, pollutant]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            A list of numbers of each model type.</span>

<span class="sd">            [nSubcatchments, nNodes, nLinks, nSystems(1), nPollutants]</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"_project_size"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_project_size</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project_size</span>

    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">_load_project_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="sd">"""Load model size into self._project_size"""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_project_size</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">get_proj_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pollutants</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">"""Return a tuple of pollutants available in SWMM binary output file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">         Tuple[str]</span>
<span class="sd">           A tuple of pollutant names.</span>

<span class="sd">        """</span>

        <span class="c1"># chose not to write a pollutant loader method</span>
        <span class="c1"># because loading such is kind of imperative to the functionality</span>
        <span class="c1"># of other data getter methods, which don't necessarily</span>
        <span class="c1"># call pollutants method. Instead, pollutant loading logic is</span>
        <span class="c1"># thrown in the _open() method, and this method calls open if</span>
        <span class="c1"># pollutants are not available.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pollutants</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pollutants</span>

    <span class="nd">@property</span>  <span class="c1"># type: ignore</span>
    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">"""Return SWMM binary output file unit type from `swmm.toolkit.shared_enum.UnitSystem`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[int]</span>
<span class="sd">            Tuple of integers indicating system units, flow units, and units for each pollutant.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">get_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">))</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">"""Return SWMM binary output file unit type from `swmm.toolkit.shared_enum.UnitSystem`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[str]</span>
<span class="sd">            List of string names for system units, flow units, and units for each pollutant.</span>

<span class="sd">            Values returned are the names from swmm.toolkit.shared_enum:</span>
<span class="sd">                UnitSystem</span>
<span class="sd">                FlowUnits</span>
<span class="sd">                ConcUnits</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">shared_enum</span><span class="o">.</span><span class="n">UnitSystem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">shared_enum</span><span class="o">.</span><span class="n">FlowUnits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unit</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">shared_enum</span><span class="o">.</span><span class="n">ConcUnits</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]</span>

    <span class="nd">@property</span>  <span class="c1"># type: ignore</span>
    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">_version</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">"""Return SWMM version used to generate SWMM binary output file results.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Integer representation of SWMM version used to make output file.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">get_version</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">)</span>

    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">_objectName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_type</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">"""Get object name from SWMM binary output file using object type and object index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        object_type : int</span>
<span class="sd">            The object type from swmm.toolkit.shared_enum.ElementType.</span>
<span class="sd">        index : int</span>
<span class="sd">            The object index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            object name</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">get_elem_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">object_type</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="c1">##### timestep setters and getters #####</span>
    <span class="k">def</span> <span class="nf">_time2step</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dateTime</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">,</span>
            <span class="n">datetime</span><span class="p">,</span>
            <span class="n">Timestamp</span><span class="p">,</span>
            <span class="n">datetime64</span><span class="p">,</span>
            <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">,</span> <span class="n">datetime64</span><span class="p">]],</span>
        <span class="p">],</span>
        <span class="n">ifNone</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"nearest"</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">"""Convert datetime value to SWMM timestep index. By deafult, this returns the nearest timestep to</span>
<span class="sd">        to the requested date, so it will always return a time index available in the binary output file.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dateTime : datetime-like or string or sequence of such</span>
<span class="sd">            datetime to convert. Must be a datetime-like object or convertable</span>
<span class="sd">            with `pd.to_datetime`.</span>

<span class="sd">        ifNone : int</span>
<span class="sd">            The value to return if dateTime is None, defaults to 0.</span>

<span class="sd">        method: str</span>
<span class="sd">            The method name to pass to pandas `get_indexer`_, default to "nearest.</span>

<span class="sd">            .. _get_indexer: https://pandas.pydata.org/docs/reference/api/pandas.Index.get_indexer.html</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[int, np.ndarray]</span>
<span class="sd">            SWMM model time step or array of time steps</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">dateTime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">ifNone</span><span class="p">]</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">dateTime</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># if passing swmm time step, no indexing necessary</span>
        <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># ensure datetime value</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">dateTime</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeIndex</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timeIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeIndex</span><span class="p">:</span>
        <span class="sd">"""Returns DatetimeIndex of reporting timeseries in binary output file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DatetimeIndex</span>
<span class="sd">            A pandas `DatetimeIndex`_ for each reporting timestep.</span>

<span class="sd">            .. _DatetimeIndex: https://pandas.pydata.org/docs/reference/api/pandas.DatetimeIndex.html?highlight=datetimeindex#pandas.DatetimeIndex</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"_timeIndex"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_timeIndex</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeIndex</span>

    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">_load_timeIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="sd">"""Load model reporting times into self._times"""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timeIndex</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_report</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span>
                <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_period</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="c1">##### model element setters and getters #####</span>
    <span class="k">def</span> <span class="nf">_subcatchmentIndex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">subcatchment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">"""Get the swmm index for subcatchment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subcatchment : Union[str, int, Sequence[Union[str, int]]]</span>
<span class="sd">            The name(s) of subcatchment(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[List[int], int]</span>
<span class="sd">           The SWMM index(s) of subcatchment(s).</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subcatchment</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elementIndex</span><span class="p">(</span><span class="n">subcatchment</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcatchments</span><span class="p">,</span> <span class="s2">"subcatchment"</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">subcatchment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_elementIndex</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcatchments</span><span class="p">,</span> <span class="s2">"subcatchment"</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">subcatchment</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Invalid type for _subcatchmentIndex argument"</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">subcatchments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">"""Return a tuple of subcatchments available in SWMM output binary file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[str]</span>
<span class="sd">            A tuple of model subcatchment names.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"_subcatchments"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_subcatchments</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcatchments</span>

    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">_load_subcatchments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="sd">"""Load model size into self._project_size"""</span>
        <span class="n">total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_subcatchments</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_objectName</span><span class="p">(</span><span class="n">shared_enum</span><span class="o">.</span><span class="n">ElementType</span><span class="o">.</span><span class="n">SUBCATCH</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_nodeIndex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">"""Get the swmm index for node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : Union[str, int, Sequence[Union[str, int]]]</span>
<span class="sd">            The name(s) of node(s)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[List[int], int]</span>
<span class="sd">            The SWMM index(s) of node(s).</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elementIndex</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="s2">"node"</span><span class="p">)</span>

        <span class="c1"># elif here because mypy issues</span>
        <span class="k">elif</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_elementIndex</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="s2">"node"</span><span class="p">)</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">node</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Invalid type for self._nodeIndex argument"</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">"""Return a tuple of nodes available in SWMM binary output file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[str]</span>
<span class="sd">            A tuple of model node names.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"_nodes"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_nodes</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span>

    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">_load_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="sd">"""Load model nodes into self._nodes"""</span>
        <span class="n">total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_objectName</span><span class="p">(</span><span class="n">shared_enum</span><span class="o">.</span><span class="n">ElementType</span><span class="o">.</span><span class="n">NODE</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_linkIndex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">link</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">"""Get the swmm index for link.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        link : Union[str, int, Sequence[Union[str, int]]]</span>
<span class="sd">            The name(s) of link(s)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[List[int], int]</span>
<span class="sd">            SWMM index(s) of link(s).</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elementIndex</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="s2">"link"</span><span class="p">)</span>

        <span class="c1"># elif here because mypy issues</span>
        <span class="k">elif</span> <span class="n">link</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_elementIndex</span><span class="p">(</span><span class="n">lnk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="s2">"link"</span><span class="p">)</span> <span class="k">for</span> <span class="n">lnk</span> <span class="ow">in</span> <span class="n">link</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Invalid type for self._linkIndex argument"</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">links</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">"""Return a tuple of links available in SWMM binary output file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[str]</span>
<span class="sd">            A tuple of model link names.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"_links"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_links</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_links</span>

    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">_load_links</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="sd">"""Load model links into self._links"""</span>
        <span class="n">total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_links</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_objectName</span><span class="p">(</span><span class="n">shared_enum</span><span class="o">.</span><span class="n">ElementType</span><span class="o">.</span><span class="n">LINK</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1">####### series getters #######</span>

    <span class="k">def</span> <span class="nf">_model_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elementIndexArray</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">attributeIndexArray</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Enum</span><span class="p">],</span>
        <span class="n">startIndex</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">endIndex</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">getterFunc</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        Base series getter for any attribute. The function consilidates the logic</span>
<span class="sd">        necessary to build long or wide timeseries dataframes for each type of swmm</span>
<span class="sd">        model element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elementIndexArray : List[int]</span>
<span class="sd">            Array of SWMM model element indicies</span>
<span class="sd">        attributeIndexArray : List[enum]</span>
<span class="sd">            Array of attribute Enums to pull for each element</span>
<span class="sd">        startIndex : int</span>
<span class="sd">            SWMM simulation time index to start timeseries</span>
<span class="sd">        endIndex : int</span>
<span class="sd">            SWMM simulation time index to end timeseries</span>
<span class="sd">        columns : Optional[str]</span>
<span class="sd">             Decide whether or not to break out elements or attributes as columns. May be one of:</span>

<span class="sd">             None   : Return long-form data with one column for each data point</span>

<span class="sd">            'elem' : Return data with a column for each element. If more than one attribute are given, attribute names are added to the index.</span>

<span class="sd">            'attr' : Return data with a column for each attribute. If more than one element are given, element names are added to the index.</span>

<span class="sd">        getterFunc : Callable</span>
<span class="sd">            The swmm.toolkit series getter function. Should be one of:</span>

<span class="sd">             swmm.toolkit.output.get_subcatch_series</span>
<span class="sd">             swmm.toolkit.output.get_node_series</span>
<span class="sd">             swmm.toolkit.output.get_link_series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            array of SWMM timeseries results</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Value error if columns is not one of "elem", "attr", or None</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="n">columns</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">"elem"</span><span class="p">,</span> <span class="s2">"attr"</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">"columns must be one of 'elem','attr', or None. </span><span class="si">{</span><span class="n">columns</span><span class="si">}</span><span class="s2"> was given"</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">getterFunc</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">elemIdx</span><span class="p">,</span> <span class="n">Attr</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">endIndex</span>
                            <span class="p">)</span>
                            <span class="k">for</span> <span class="n">Attr</span> <span class="ow">in</span> <span class="n">attributeIndexArray</span>
                        <span class="p">],</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">elemIdx</span> <span class="ow">in</span> <span class="n">elementIndexArray</span>
                <span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">columns</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"attr"</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">stack</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">getterFunc</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">elemIdx</span><span class="p">,</span> <span class="n">Attr</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">endIndex</span>
                            <span class="p">)</span>
                            <span class="k">for</span> <span class="n">Attr</span> <span class="ow">in</span> <span class="n">attributeIndexArray</span>
                        <span class="p">],</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">elemIdx</span> <span class="ow">in</span> <span class="n">elementIndexArray</span>
                <span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">columns</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"elem"</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">stack</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">getterFunc</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">elemIdx</span><span class="p">,</span> <span class="n">Attr</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">endIndex</span>
                            <span class="p">)</span>
                            <span class="k">for</span> <span class="n">elemIdx</span> <span class="ow">in</span> <span class="n">elementIndexArray</span>
                        <span class="p">],</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">Attr</span> <span class="ow">in</span> <span class="n">attributeIndexArray</span>
                <span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_model_series_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elementArray</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">attributeArray</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">startIndex</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">endIndex</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        Base dataframe index getter for model timeseries. The function consilidates the logic</span>
<span class="sd">        necessary to build a data frame index for long or wide dataframes built with time series</span>
<span class="sd">        getters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elementArray : List[str]</span>
<span class="sd">            Array of SWMM model element names</span>
<span class="sd">        attributeArray : List[str]</span>
<span class="sd">            Array of attribute names pulled for each element</span>
<span class="sd">        startIndex : int</span>
<span class="sd">            SWMM simulation time index to start timeseries</span>
<span class="sd">        endIndex : int</span>
<span class="sd">            SWMM simulation time index to end timeseries</span>
<span class="sd">        columns : Optional[str]</span>
<span class="sd">             Decide whether or not to break out elements or attributes as columns. May be one of:</span>

<span class="sd">             None   : Return long-form data with one column for each data point</span>

<span class="sd">            'elem' : Return data with a column for each element. If more than one attribute are given, attribute names are added to the index.</span>

<span class="sd">            'attr' : Return data with a column for each attribute. If more than one element are given, element names are added to the index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (pd.MultiIndex, Union[list,np.ndarray])</span>
<span class="sd">            A pandas MultiIndex for the row indicies and an iterable of column names</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Value error if columns is not one of "elem", "attr", or None</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="n">columns</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">"elem"</span><span class="p">,</span> <span class="s2">"attr"</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">"columns must be one of 'elem','attr', or None. </span><span class="si">{</span><span class="n">columns</span><span class="si">}</span><span class="s2"> was given"</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtIndex</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">timeIndex</span><span class="p">[</span><span class="n">startIndex</span><span class="p">:</span><span class="n">endIndex</span><span class="p">],</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">elementArray</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributeArray</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">indexArrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtIndex</span><span class="p">]</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"datetime"</span><span class="p">]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Result"</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elementArray</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indexArrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">asarray</span><span class="p">(</span><span class="n">elementArray</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">endIndex</span> <span class="o">-</span> <span class="n">startIndex</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributeArray</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"element"</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributeArray</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indexArrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">tile</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">attributeArray</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">elementArray</span><span class="p">))</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                        <span class="n">endIndex</span> <span class="o">-</span> <span class="n">startIndex</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"attribute"</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">columns</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"attr"</span><span class="p">:</span>
            <span class="n">dtIndex</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeIndex</span><span class="p">[</span><span class="n">startIndex</span><span class="p">:</span><span class="n">endIndex</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">elementArray</span><span class="p">))</span>
            <span class="n">indexArrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtIndex</span><span class="p">]</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"datetime"</span><span class="p">]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">attributeArray</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elementArray</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indexArrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">elementArray</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">endIndex</span> <span class="o">-</span> <span class="n">startIndex</span><span class="p">))</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"element"</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">columns</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"elem"</span><span class="p">:</span>
            <span class="n">dtIndex</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeIndex</span><span class="p">[</span><span class="n">startIndex</span><span class="p">:</span><span class="n">endIndex</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributeArray</span><span class="p">))</span>
            <span class="n">indexArrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtIndex</span><span class="p">]</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"datetime"</span><span class="p">]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">elementArray</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributeArray</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indexArrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">asarray</span><span class="p">(</span><span class="n">attributeArray</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">endIndex</span> <span class="o">-</span> <span class="n">startIndex</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"attribute"</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                <span class="n">indexArrays</span><span class="p">,</span>
                <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexArrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="k">else</span> <span class="n">Index</span><span class="p">(</span><span class="n">indexArrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">index</span><span class="p">,</span> <span class="n">cols</span>

<div class="viewcode-block" id="Output.subcatch_series"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.subcatch_series.html#swmm.pandas.Output.subcatch_series">[docs]</a>    <span class="k">def</span> <span class="nf">subcatch_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">subcatchment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">"rainfall"</span><span class="p">,</span>
            <span class="s2">"runoff_rate"</span><span class="p">,</span>
            <span class="s2">"gw_outflow_rate"</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"attr"</span><span class="p">,</span>
        <span class="n">asframe</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">"""Get one or more time series for one or more subcatchment attributes.</span>
<span class="sd">        Specify series start index and end index to get desired time range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subcatchment : Union[int, str, Sequence[Union[int, str]], None]</span>
<span class="sd">            The subcatchment index or name.</span>

<span class="sd">        attribute : Union[int, str, Enum, Sequence[Union[int, str, Enum]], None],</span>
<span class="sd">            The attribute index or name.</span>

<span class="sd">            On of:</span>

<span class="sd">            **rainfall, snow_depth, evap_loss, infil_loss, runoff_rate, gw_outflow_rate,</span>
<span class="sd">            gw_table_elev, soil_moisture**.</span>


<span class="sd">            Defaults to: `('rainfall', 'runoff_rate', 'gw_outflow_rate').`</span>


<span class="sd">            Can also input the integer index of the attribute you would like to</span>
<span class="sd">            pull or the actual enum from Output.subcatch_attributes.</span>

<span class="sd">            Setting to None indicates all attributes.</span>

<span class="sd">        start : Union[str,int, datetime, None], optional</span>
<span class="sd">            The start datetime or index of from which to return series, defaults to None.</span>

<span class="sd">            Setting to None indicates simulation start.</span>

<span class="sd">        end : Union[str,int, datetime, None], optional</span>
<span class="sd">            The end datetime or index of from which to return series, defaults to None.</span>

<span class="sd">            Setting to None indicates simulation end.</span>

<span class="sd">        columns: Optional[str], optional</span>
<span class="sd">            Decide whether or not to break out elements or attributes as columns. May be one of:</span>

<span class="sd">            None   : Return long-form data with one column for each data point</span>

<span class="sd">            'elem' : Return data with a column for each element. If more than one attribute are given, attribute names are added to the index.</span>

<span class="sd">            'attr' : Return data with a column for each attribute. If more than one element are given, element names are added to the index.</span>

<span class="sd">            defaults to 'attr'.</span>

<span class="sd">        asframe: bool</span>
<span class="sd">            A switch to return an indexed DataFrame. Set to False to get an array of values only, defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pd.DataFrame,np.ndarray]</span>
<span class="sd">            A DataFrame or ndarray of attribute values in each column for requested</span>
<span class="sd">            date range and subcatchments.</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>

<span class="sd">        Pull single time series for a single subcatchment</span>

<span class="sd">        &gt;&gt;&gt; from swmm.pandas import Output,test_out_path</span>
<span class="sd">        &gt;&gt;&gt; out = Output(test_out_path)</span>
<span class="sd">        &gt;&gt;&gt; out.subcatch_series('SUB1', 'runoff_rate')</span>
<span class="sd">                             runoff_rate</span>
<span class="sd">        datetime</span>
<span class="sd">        1900-01-01 00:05:00     0.000000</span>
<span class="sd">        1900-01-01 00:10:00     0.000000</span>
<span class="sd">        1900-01-01 00:15:00     0.000000</span>
<span class="sd">        1900-01-01 00:20:00     0.000000</span>
<span class="sd">        1900-01-01 00:25:00     0.000000</span>
<span class="sd">        ...                          ...</span>
<span class="sd">        1900-01-01 23:40:00     0.025057</span>
<span class="sd">        1900-01-01 23:45:00     0.025057</span>
<span class="sd">        1900-01-01 23:50:00     0.025057</span>
<span class="sd">        1900-01-01 23:55:00     0.025057</span>
<span class="sd">        1900-01-02 00:00:00     0.025057</span>
<span class="sd">        [288 rows x 1 columns]</span>

<span class="sd">        Pull a wide-form dataframe for all parameters for a catchment</span>

<span class="sd">        &gt;&gt;&gt; out.subcatch_series('SUB1', out.subcatch_attributes)</span>
<span class="sd">                            rainfall  snow_depth  evap_loss  infil_loss  ...  soil_moisture  groundwater  pol_rainfall  sewage</span>
<span class="sd">        datetime                                                          ...</span>
<span class="sd">        1900-01-01 00:05:00   0.03000         0.0        0.0    0.020820  ...       0.276035          0.0           0.0     0.0</span>
<span class="sd">        1900-01-01 00:10:00   0.03000         0.0        0.0    0.020952  ...       0.276053          0.0           0.0     0.0</span>
<span class="sd">        1900-01-01 00:15:00   0.03000         0.0        0.0    0.021107  ...       0.276071          0.0           0.0     0.0</span>
<span class="sd">        1900-01-01 00:20:00   0.03000         0.0        0.0    0.021260  ...       0.276089          0.0           0.0     0.0</span>
<span class="sd">        1900-01-01 00:25:00   0.03000         0.0        0.0    0.021397  ...       0.276107          0.0           0.0     0.0</span>
<span class="sd">        ...                       ...         ...        ...         ...  ...            ...          ...           ...     ...</span>
<span class="sd">        1900-01-01 23:40:00   0.03224         0.0        0.0    0.027270  ...       0.280026          0.0         100.0     0.0</span>
<span class="sd">        1900-01-01 23:45:00   0.03224         0.0        0.0    0.027270  ...       0.280026          0.0         100.0     0.0</span>
<span class="sd">        1900-01-01 23:50:00   0.03224         0.0        0.0    0.027270  ...       0.280026          0.0         100.0     0.0</span>
<span class="sd">        1900-01-01 23:55:00   0.03224         0.0        0.0    0.027270  ...       0.280026          0.0         100.0     0.0</span>
<span class="sd">        1900-01-02 00:00:00   0.00000         0.0        0.0    0.027270  ...       0.280026          0.0         100.0     0.0</span>
<span class="sd">        [288 rows x 11 columns]</span>

<span class="sd">        Pull a long-form dataframe of all catchments and attributes</span>

<span class="sd">        &gt;&gt;&gt; out.subcatch_series(out.subcatchments, out.subcatch_attributes, columns=None)</span>
<span class="sd">                                               Result</span>
<span class="sd">        datetime            element attribute</span>
<span class="sd">        1900-01-01 00:05:00 SUB1    rainfall     0.03</span>
<span class="sd">        1900-01-01 00:10:00 SUB1    rainfall     0.03</span>
<span class="sd">        1900-01-01 00:15:00 SUB1    rainfall     0.03</span>
<span class="sd">        1900-01-01 00:20:00 SUB1    rainfall     0.03</span>
<span class="sd">        1900-01-01 00:25:00 SUB1    rainfall     0.03</span>
<span class="sd">        ...                                       ...</span>
<span class="sd">        1900-01-01 23:40:00 SUB3    sewage       0.00</span>
<span class="sd">        1900-01-01 23:45:00 SUB3    sewage       0.00</span>
<span class="sd">        1900-01-01 23:50:00 SUB3    sewage       0.00</span>
<span class="sd">        1900-01-01 23:55:00 SUB3    sewage       0.00</span>
<span class="sd">        1900-01-02 00:00:00 SUB3    sewage       0.00</span>
<span class="sd">        [9504 rows x 1 columns]</span>

<span class="sd">        Pull two parameters for one subcatchment and plot the results</span>

<span class="sd">        .. plot::</span>

<span class="sd">           import matplotlib.pyplot as plt</span>
<span class="sd">           from matplotlib.dates import DateFormatter</span>
<span class="sd">           from swmm.pandas import Output,test_out_path</span>

<span class="sd">           # read output file in Output object</span>
<span class="sd">           out = Output(test_out_path)</span>

<span class="sd">           # pull rainfall and runoff_rate timeseries and plot them</span>
<span class="sd">           ax = out.subcatch_series('SUB1', ['rainfall', 'runoff_rate']).plot(figsize=(8,4))</span>
<span class="sd">           plt.title("SUB1 Params")</span>
<span class="sd">           plt.tight_layout()</span>
<span class="sd">           plt.show()</span>

<span class="sd">        Pull the one parameter for all subcatchments</span>

<span class="sd">        .. plot::</span>

<span class="sd">           import matplotlib.pyplot as plt</span>
<span class="sd">           from matplotlib.dates import DateFormatter</span>
<span class="sd">           from swmm.pandas import Output,test_out_path</span>

<span class="sd">           # read output file in Output object</span>
<span class="sd">           out = Output(test_out_path)</span>

<span class="sd">           # pull runoff_rate timeseries for all cathments and plot them</span>
<span class="sd">           ax = out.subcatch_series(out.subcatchments, 'runoff_rate', columns='elem').plot(figsize=(8,4))</span>
<span class="sd">           plt.title("Runoff Rate")</span>
<span class="sd">           plt.tight_layout()</span>
<span class="sd">           plt.show()</span>


<span class="sd">        """</span>
        <span class="n">subcatchementArray</span><span class="p">,</span> <span class="n">subcatchmentIndexArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateElement</span><span class="p">(</span>
            <span class="n">subcatchment</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcatchments</span>
        <span class="p">)</span>

        <span class="n">attributeArray</span><span class="p">,</span> <span class="n">attributeIndexArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateAttribute</span><span class="p">(</span>
            <span class="n">attribute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcatch_attributes</span>
        <span class="p">)</span>

        <span class="n">startIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">endIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_period</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_series</span><span class="p">(</span>
            <span class="n">subcatchmentIndexArray</span><span class="p">,</span>
            <span class="n">attributeIndexArray</span><span class="p">,</span>
            <span class="n">startIndex</span><span class="p">,</span>
            <span class="n">endIndex</span><span class="p">,</span>
            <span class="n">columns</span><span class="p">,</span>
            <span class="n">output</span><span class="o">.</span><span class="n">get_subcatch_series</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>

        <span class="n">dfIndex</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_series_index</span><span class="p">(</span>
            <span class="n">subcatchementArray</span><span class="p">,</span> <span class="n">attributeArray</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">endIndex</span><span class="p">,</span> <span class="n">columns</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dfIndex</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span></div>

<div class="viewcode-block" id="Output.node_series"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.node_series.html#swmm.pandas.Output.node_series">[docs]</a>    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">node_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">"invert_depth"</span><span class="p">,</span>
            <span class="s2">"flooding_losses"</span><span class="p">,</span>
            <span class="s2">"total_inflow"</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"attr"</span><span class="p">,</span>
        <span class="n">asframe</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">"""Get one or more time series for one or more node attributes.</span>
<span class="sd">        Specify series start index and end index to get desired time range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : Union[int, str, Sequence[Union[int, str]], None]</span>
<span class="sd">            The node index or name.</span>

<span class="sd">        attribute : Union[int, str, Enum, Sequence[Union[int, str, Enum]], None],</span>
<span class="sd">            The attribute index or name.</span>

<span class="sd">            On of:</span>

<span class="sd">            **invert_depth, hydraulic_head, ponded_volume, lateral_inflow,</span>
<span class="sd">            total_inflow, flooding_losses**.</span>

<span class="sd">            defaults to: `('invert_depth','flooding_losses','total_inflow')`</span>

<span class="sd">            Can also input the integer index of the attribute you would like to</span>
<span class="sd">            pull or the actual enum from Output.node_attributes.</span>

<span class="sd">            Setting to None indicates all attributes.</span>

<span class="sd">        start : Union[str, int, datetime, None], optional</span>
<span class="sd">            The start datetime or index of from which to return series, defaults to None.</span>

<span class="sd">            Setting to None indicates simulation start.</span>

<span class="sd">        end : Union[str, int, datetime, None], optional</span>
<span class="sd">            The end datetime or index of from which to return series, defaults to None.</span>

<span class="sd">            Setting to None indicates simulation end.</span>

<span class="sd">        columns: Optional[str], optional</span>
<span class="sd">            Decide whether or not to break out elements or attributes as columns. May be one of:</span>

<span class="sd">            None   : Return long-form data with one column for each data point</span>

<span class="sd">            'elem' : Return data with a column for each element. If more than one attribute are given, attribute names are added to the index.</span>

<span class="sd">            'attr' : Return data with a column for each attribute. If more than one element are given, element names are added to the index.</span>

<span class="sd">            defaults to 'attr'.</span>

<span class="sd">        asframe: bool</span>
<span class="sd">            A switch to return an indexed DataFrame. Set to False to get an array of values only, defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pd.DataFrame,np.ndarray]</span>
<span class="sd">            A DataFrame or ndarray of attribute values in each column for requested</span>
<span class="sd">            date range and nodes.</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>

<span class="sd">        Pull single time series for a single node</span>

<span class="sd">        &gt;&gt;&gt; from swmm.pandas import Output,test_out_path</span>
<span class="sd">        &gt;&gt;&gt; out = Output(test_out_path)</span>
<span class="sd">        &gt;&gt;&gt; out.node_series('JUNC2', 'invert_depth')</span>
<span class="sd">                             invert_depth</span>
<span class="sd">        datetime</span>
<span class="sd">        1900-01-01 00:05:00      0.334742</span>
<span class="sd">        1900-01-01 00:10:00      0.509440</span>
<span class="sd">        1900-01-01 00:15:00      0.562722</span>
<span class="sd">        1900-01-01 00:20:00      0.602668</span>
<span class="sd">        1900-01-01 00:25:00      0.631424</span>
<span class="sd">        ...                           ...</span>
<span class="sd">        1900-01-01 23:40:00      0.766949</span>
<span class="sd">        1900-01-01 23:45:00      0.766949</span>
<span class="sd">        1900-01-01 23:50:00      0.766949</span>
<span class="sd">        1900-01-01 23:55:00      0.766949</span>
<span class="sd">        1900-01-02 00:00:00      0.766949</span>
<span class="sd">        [288 rows x 1 columns]</span>

<span class="sd">        Pull a wide-form dataframe for all parameters for a node</span>

<span class="sd">        &gt;&gt;&gt; out.node_series('JUNC2', out.node_attributes)</span>
<span class="sd">                           invert_depth  hydraulic_head  ponded_volume  lateral_inflow  total_inflow  flooding_losses  groundwater  pol_rainfall     sewage</span>
<span class="sd">        datetime</span>
<span class="sd">        1900-01-01 00:05:00      0.334742       -0.705258            0.0        0.185754      0.185785              0.0     3.935642      0.000000  95.884094</span>
<span class="sd">        1900-01-01 00:10:00      0.509440       -0.530560            0.0        0.196764      0.197044              0.0     8.902034      0.000000  90.335831</span>
<span class="sd">        1900-01-01 00:15:00      0.562722       -0.477278            0.0        0.198615      0.199436              0.0     9.038609      0.000000  89.253334</span>
<span class="sd">        1900-01-01 00:20:00      0.602668       -0.437332            0.0        0.200802      0.202462              0.0     9.259741      0.000000  87.919571</span>
<span class="sd">        1900-01-01 00:25:00      0.631424       -0.408576            0.0        0.203108      0.205802              0.0     9.523322      0.000000  86.492836</span>
<span class="sd">        ...                           ...             ...            ...             ...           ...              ...          ...           ...        ...</span>
<span class="sd">        1900-01-01 23:40:00      0.766949       -0.273052            0.0        0.314470      0.352183              0.0    15.293419     39.303375  45.430920</span>
<span class="sd">        1900-01-01 23:45:00      0.766949       -0.273052            0.0        0.314499      0.352183              0.0    15.313400     39.292118  45.430920</span>
<span class="sd">        1900-01-01 23:50:00      0.766949       -0.273052            0.0        0.314530      0.352183              0.0    15.333243     39.281300  45.430920</span>
<span class="sd">        1900-01-01 23:55:00      0.766949       -0.273052            0.0        0.314559      0.352183              0.0    15.352408     39.271194  45.430920</span>
<span class="sd">        1900-01-02 00:00:00      0.766949       -0.273052            0.0        0.314590      0.352183              0.0    15.371475     39.261478  45.430920</span>
<span class="sd">        [288 rows x 9 columns]</span>

<span class="sd">        Pull a long-form dataframe of all nodes and attributes</span>

<span class="sd">        &gt;&gt;&gt; out.node_series('JUNC2', out.node_attributes, columns=None)</span>
<span class="sd">                                                    Result</span>
<span class="sd">        datetime            element attribute</span>
<span class="sd">        1900-01-01 00:05:00 JUNC1   invert_depth   0.002143</span>
<span class="sd">        1900-01-01 00:10:00 JUNC1   invert_depth   0.010006</span>
<span class="sd">        1900-01-01 00:15:00 JUNC1   invert_depth   0.017985</span>
<span class="sd">        1900-01-01 00:20:00 JUNC1   invert_depth   0.025063</span>
<span class="sd">        1900-01-01 00:25:00 JUNC1   invert_depth   0.031329</span>
<span class="sd">        ...                                             ...</span>
<span class="sd">        1900-01-01 23:40:00 STOR1   sewage        51.502193</span>
<span class="sd">        1900-01-01 23:45:00 STOR1   sewage        51.164684</span>
<span class="sd">        1900-01-01 23:50:00 STOR1   sewage        50.905445</span>
<span class="sd">        1900-01-01 23:55:00 STOR1   sewage        50.715385</span>
<span class="sd">        1900-01-02 00:00:00 STOR1   sewage        50.574486</span>
<span class="sd">        [23328 rows x 1 columns]</span>

<span class="sd">        Pull flow timeseries and calculate the total flow volume for all nodes</span>


<span class="sd">        &gt;&gt;&gt; from swmm.pandas.constants import gal_per_cf</span>
<span class="sd">        &gt;&gt;&gt; df = out.node_series(out.nodes, ['lateral_inflow','total_inflow','flooding_losses'])</span>
<span class="sd">                                     lateral_inflow  total_inflow  flooding_losses</span>
<span class="sd">        datetime            element</span>
<span class="sd">        1900-01-01 00:05:00 JUNC1          0.002362      0.002362              0.0</span>
<span class="sd">        1900-01-01 00:10:00 JUNC1          0.005792      0.005792              0.0</span>
<span class="sd">        1900-01-01 00:15:00 JUNC1          0.006524      0.006524              0.0</span>
<span class="sd">        1900-01-01 00:20:00 JUNC1          0.007306      0.007306              0.0</span>
<span class="sd">        1900-01-01 00:25:00 JUNC1          0.008039      0.008039              0.0</span>
<span class="sd">        ...                                     ...           ...              ...</span>
<span class="sd">        1900-01-01 23:40:00 STOR1          0.000000      1.455056              0.0</span>
<span class="sd">        1900-01-01 23:45:00 STOR1          0.000000      1.455056              0.0</span>
<span class="sd">        1900-01-01 23:50:00 STOR1          0.000000      1.455056              0.0</span>
<span class="sd">        1900-01-01 23:55:00 STOR1          0.000000      1.455056              0.0</span>
<span class="sd">        1900-01-02 00:00:00 STOR1          0.000000      1.455056              0.0</span>
<span class="sd">        [2592 rows x 3 columns]</span>
<span class="sd">        #----------------------------------------------------------------------------</span>
<span class="sd">        # group by element name and sum,</span>
<span class="sd">        # then multiply by reporting timestep in seconds</span>
<span class="sd">        # then convert to millions of gallons</span>
<span class="sd">        &gt;&gt;&gt; df.groupby('element').sum() * out.report * gal_per_cf / 1e6</span>
<span class="sd">                lateral_inflow  total_inflow  flooding_losses</span>
<span class="sd">        element</span>
<span class="sd">        JUNC1          0.101562      0.101898         0.000053</span>
<span class="sd">        JUNC2          0.544891      0.857012         0.000000</span>
<span class="sd">        JUNC3          0.000000      0.502078         0.080634</span>
<span class="sd">        JUNC4          1.813826      2.096243         0.317929</span>
<span class="sd">        JUNC5          0.000000      1.870291         0.073878</span>
<span class="sd">        JUNC6          0.000000      1.701455         0.000000</span>
<span class="sd">        OUT1           0.000000      1.698081         0.000000</span>
<span class="sd">        OUT2           0.000000      0.575617         0.000000</span>
<span class="sd">        STOR1          0.000000      1.862843         0.172482</span>
<span class="sd">        """</span>
        <span class="n">nodeArray</span><span class="p">,</span> <span class="n">nodeIndexArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateElement</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

        <span class="n">attributeArray</span><span class="p">,</span> <span class="n">attributeIndexArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateAttribute</span><span class="p">(</span>
            <span class="n">attribute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span>
        <span class="p">)</span>

        <span class="n">startIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">endIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_period</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_series</span><span class="p">(</span>
            <span class="n">nodeIndexArray</span><span class="p">,</span>
            <span class="n">attributeIndexArray</span><span class="p">,</span>
            <span class="n">startIndex</span><span class="p">,</span>
            <span class="n">endIndex</span><span class="p">,</span>
            <span class="n">columns</span><span class="p">,</span>
            <span class="n">output</span><span class="o">.</span><span class="n">get_node_series</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>

        <span class="n">dfIndex</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_series_index</span><span class="p">(</span>
            <span class="n">nodeArray</span><span class="p">,</span> <span class="n">attributeArray</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">endIndex</span><span class="p">,</span> <span class="n">columns</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dfIndex</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span></div>

<div class="viewcode-block" id="Output.link_series"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.link_series.html#swmm.pandas.Output.link_series">[docs]</a>    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">link_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">link</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">"flow_rate"</span><span class="p">,</span>
            <span class="s2">"flow_velocity"</span><span class="p">,</span>
            <span class="s2">"flow_depth"</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"attr"</span><span class="p">,</span>
        <span class="n">asframe</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">"""Get one or more time series for one or more link attributes.</span>
<span class="sd">        Specify series start index and end index to get desired time range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        link : Union[int, str, Sequence[Union[int, str]], None]</span>
<span class="sd">            The link index or name.</span>

<span class="sd">        attribute : Union[int, str, Enum, Sequence[Union[int, str, Enum]], None]</span>
<span class="sd">            The attribute index or name.</span>

<span class="sd">            On of:</span>

<span class="sd">            **flow_rate, flow_depth, flow_velocity, flow_volume, capacity**.</span>

<span class="sd">            defaults to: `('flow_rate','flow_velocity','flow_depth')`</span>

<span class="sd">            Can also input the integer index of the attribute you would like to</span>
<span class="sd">            pull or the actual enum from output.link_attributes.</span>

<span class="sd">            Setting to None indicates all attributes.</span>

<span class="sd">        start_index : Union[str,int, datetime, None], optional</span>
<span class="sd">            The start datetime or index of from which to return series, defaults to None.</span>

<span class="sd">            Setting to None indicates simulation start.</span>

<span class="sd">        end_index : Union[str,int, datetime, None], optional</span>
<span class="sd">            The end datetime or index of from which to return series, defaults to None.</span>

<span class="sd">            Setting to None indicates simulation end.</span>

<span class="sd">        columns: Optional[str], optional</span>
<span class="sd">            Decide whether or not to break out elements or attributes as columns. May be one of:</span>

<span class="sd">            None   : Return long-form data with one column for each data point</span>

<span class="sd">            'elem' : Return data with a column for each element. If more than one attribute are given, attribute names are added to the index.</span>

<span class="sd">            'attr' : Return data with a column for each attribute. If more than one element are given, element names are added to the index.</span>

<span class="sd">            defaults to 'attr'.</span>

<span class="sd">        asframe: bool</span>
<span class="sd">            A switch to return an indexed DataFrame. Set to False to get an array of values only, defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pd.DataFrame,np.ndarray]</span>
<span class="sd">            A DataFrame or ndarray of attribute values in each column for requested</span>
<span class="sd">            date range and links.</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>

<span class="sd">        Pull flow rate for two conduits</span>

<span class="sd">        &gt;&gt;&gt; from swmm.pandas import Output,test_out_path</span>
<span class="sd">        &gt;&gt;&gt; out = Output(test_out_path)</span>
<span class="sd">        &gt;&gt;&gt; out.link_series(['COND1','COND6'],out.link_attributes.FLOW_RATE,columns='elem')</span>
<span class="sd">                                COND1   COND6</span>
<span class="sd">        datetime</span>
<span class="sd">        1900-01-01 00:05:00  0.000031  0.0000</span>
<span class="sd">        1900-01-01 00:10:00  0.000280  0.0000</span>
<span class="sd">        1900-01-01 00:15:00  0.000820  0.0000</span>
<span class="sd">        1900-01-01 00:20:00  0.001660  0.0000</span>
<span class="sd">        1900-01-01 00:25:00  0.002694  0.0000</span>
<span class="sd">        ...                       ...     ...</span>
<span class="sd">        1900-01-01 23:40:00  0.037800  1.5028</span>
<span class="sd">        1900-01-01 23:45:00  0.037800  1.5028</span>
<span class="sd">        1900-01-01 23:50:00  0.037800  1.5028</span>
<span class="sd">        1900-01-01 23:55:00  0.037800  1.5028</span>
<span class="sd">        1900-01-02 00:00:00  0.037800  1.5028</span>
<span class="sd">        [288 rows x 2 columns]</span>

<span class="sd">        Pull a wide-form dataframe for all parameters for a link</span>

<span class="sd">        &gt;&gt;&gt; out.node_series('COND1', out.link_attributes)</span>
<span class="sd">                            flow_rate  flow_depth  flow_velocity  flow_volume  capacity  groundwater  pol_rainfall        sewage</span>
<span class="sd">        datetime</span>
<span class="sd">        1900-01-01 00:05:00   0.000031    0.053857       0.001116    23.910770  0.024351    79.488449      0.000000  0.000000e+00</span>
<span class="sd">        1900-01-01 00:10:00   0.000280    0.134876       0.004258    76.354103  0.080857    93.174545      0.000000  0.000000e+00</span>
<span class="sd">        1900-01-01 00:15:00   0.000820    0.165356       0.009518    99.407425  0.108456    91.125893      0.000000  0.000000e+00</span>
<span class="sd">        1900-01-01 00:20:00   0.001660    0.188868       0.016023   117.895081  0.131204    88.518318      0.000000  0.000000e+00</span>
<span class="sd">        1900-01-01 00:25:00   0.002694    0.206378       0.022971   131.773941  0.148936    86.187752      0.000000  0.000000e+00</span>
<span class="sd">        ...                        ...         ...            ...          ...       ...          ...           ...           ...</span>
<span class="sd">        1900-01-01 23:40:00   0.037800    0.312581       0.180144   212.443344  0.267168    31.683731     68.344780  6.173063e-08</span>
<span class="sd">        1900-01-01 23:45:00   0.037800    0.312581       0.180144   212.443344  0.267168    31.788561     68.242958  5.872794e-08</span>
<span class="sd">        1900-01-01 23:50:00   0.037800    0.312581       0.180144   212.443344  0.267168    31.890982     68.144737  5.583060e-08</span>
<span class="sd">        1900-01-01 23:55:00   0.037800    0.312581       0.180144   212.443344  0.267168    31.988274     68.052620  5.311425e-08</span>
<span class="sd">        1900-01-02 00:00:00   0.037800    0.312581       0.180144   212.443344  0.267168    32.083355     67.963829  5.049533e-08</span>

<span class="sd">        [288 rows x 8 columns]</span>

<span class="sd">        Pull a long-form dataframe of all links and attributes</span>

<span class="sd">        &gt;&gt;&gt; out.node_series(out.links, out.link_attributes, columns=None)</span>
<span class="sd">                                    flow_rate  flow_depth  flow_velocity  flow_volume  capacity  groundwater  pol_rainfall    sewage</span>
<span class="sd">        datetime            element</span>
<span class="sd">        1900-01-01 00:05:00 COND1     0.000031    0.053857       0.001116    23.910770  0.024351    79.488449      0.000000   0.00000</span>
<span class="sd">        1900-01-01 00:10:00 COND1     0.000280    0.134876       0.004258    76.354103  0.080857    93.174545      0.000000   0.00000</span>
<span class="sd">        1900-01-01 00:15:00 COND1     0.000820    0.165356       0.009518    99.407425  0.108456    91.125893      0.000000   0.00000</span>
<span class="sd">        1900-01-01 00:20:00 COND1     0.001660    0.188868       0.016023   117.895081  0.131204    88.518318      0.000000   0.00000</span>
<span class="sd">        1900-01-01 00:25:00 COND1     0.002694    0.206378       0.022971   131.773941  0.148936    86.187752      0.000000   0.00000</span>
<span class="sd">        ...                                ...         ...            ...          ...       ...          ...           ...       ...</span>
<span class="sd">        1900-01-01 23:40:00 WR1       0.000000    0.000000       0.000000     0.000000  1.000000    15.293419     39.303375  45.43092</span>
<span class="sd">        1900-01-01 23:45:00 WR1       0.000000    0.000000       0.000000     0.000000  1.000000    15.313400     39.292118  45.43092</span>
<span class="sd">        1900-01-01 23:50:00 WR1       0.000000    0.000000       0.000000     0.000000  1.000000    15.333243     39.281300  45.43092</span>
<span class="sd">        1900-01-01 23:55:00 WR1       0.000000    0.000000       0.000000     0.000000  1.000000    15.352408     39.271194  45.43092</span>
<span class="sd">        1900-01-02 00:00:00 WR1       0.000000    0.000000       0.000000     0.000000  1.000000    15.371475     39.261478  45.43092</span>
<span class="sd">        [2304 rows x 8 columns]</span>

<span class="sd">        Pull flow timeseries and pollutant tracer concentrations for a link and plot</span>

<span class="sd">        .. plot::</span>

<span class="sd">            import matplotlib.pyplot as plt</span>
<span class="sd">            import matplotlib.dates as mdates</span>
<span class="sd">            from swmm.pandas import Output,test_out_path</span>

<span class="sd">            out = Output(test_out_path)</span>
<span class="sd">            df = out.link_series('COND6',['flow_rate','groundwater','pol_rainfall','sewage'])</span>

<span class="sd">            # set up figure</span>
<span class="sd">            fig,ax = plt.subplots(figsize=(8,4))</span>

<span class="sd">            # plot flow rate on primary yaxis</span>
<span class="sd">            ax.plot(df.flow_rate,label="flow rate")</span>

<span class="sd">            # plot pollutant concentrations on secondary axis</span>
<span class="sd">            # rainfall, DWF, and groundwater were given 100 mg/L pollutant</span>
<span class="sd">            # concentrations to serve as tracers</span>
<span class="sd">            ax1 = ax.twinx()</span>
<span class="sd">            ax1.plot(df.groundwater,ls = '--',label="groundwater tracer")</span>
<span class="sd">            ax1.plot(df.pol_rainfall,ls = '--',label="rainfall tracer")</span>
<span class="sd">            ax1.plot(df.sewage,ls = '--',label="sewage tracer")</span>

<span class="sd">            # style axes</span>
<span class="sd">            ax.set_ylabel("Flow Rate (cfs)")</span>
<span class="sd">            ax.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))</span>
<span class="sd">            ax1.set_ylabel("Percent")</span>

<span class="sd">            # add legend and show figure</span>
<span class="sd">            fig.legend(bbox_to_anchor=(1,1),bbox_transform=ax.transAxes)</span>
<span class="sd">            fig.tight_layout()</span>


<span class="sd">            fig.show()</span>

<span class="sd">        """</span>
        <span class="n">linkArray</span><span class="p">,</span> <span class="n">linkIndexArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateElement</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>

        <span class="n">attributeArray</span><span class="p">,</span> <span class="n">attributeIndexArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateAttribute</span><span class="p">(</span>
            <span class="n">attribute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">link_attributes</span>
        <span class="p">)</span>

        <span class="n">startIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">endIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_period</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_series</span><span class="p">(</span>
            <span class="n">linkIndexArray</span><span class="p">,</span>
            <span class="n">attributeIndexArray</span><span class="p">,</span>
            <span class="n">startIndex</span><span class="p">,</span>
            <span class="n">endIndex</span><span class="p">,</span>
            <span class="n">columns</span><span class="p">,</span>
            <span class="n">output</span><span class="o">.</span><span class="n">get_link_series</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>

        <span class="n">dfIndex</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_series_index</span><span class="p">(</span>
            <span class="n">linkArray</span><span class="p">,</span> <span class="n">attributeArray</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">endIndex</span><span class="p">,</span> <span class="n">columns</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dfIndex</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span></div>

<div class="viewcode-block" id="Output.system_series"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.system_series.html#swmm.pandas.Output.system_series">[docs]</a>    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">system_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">asframe</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">"""Get one or more a time series for one or more system attributes.</span>
<span class="sd">        Specify series start index and end index to get desired time range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute : Union[int, str, Enum, Sequence[Union[int, str, Enum]], None]</span>
<span class="sd">            The attribute index or name.</span>

<span class="sd">            On of:</span>

<span class="sd">            **air_temp, rainfall, snow_depth, evap_infil_loss, runoff_flow,</span>
<span class="sd">            dry_weather_inflow, gw_inflow, rdii_inflow, direct_inflow, total_lateral_inflow,</span>
<span class="sd">            flood_losses, outfall_flows, volume_stored, evap_rate**.</span>

<span class="sd">            defaults to `None`.</span>

<span class="sd">            Can also input the integer index of the attribute you would like to</span>
<span class="sd">            pull or the actual enum from Output.system_attributes.</span>

<span class="sd">            Setting to None indicates all attributes.</span>

<span class="sd">        start_index : Union[str, int, datetime, None], optional</span>
<span class="sd">            The start datetime or index of from which to return series, defaults to None.</span>

<span class="sd">            Setting to None indicates simulation start.</span>

<span class="sd">        end_index : Union[str, int, datetime, None], optional</span>
<span class="sd">            The end datetime or index of from which to return series, defaults to None.</span>

<span class="sd">            Setting to None indicates simulation end.</span>

<span class="sd">        asframe: bool</span>
<span class="sd">            switch to return an indexed DataFrame. Set to False to get an array of values only, defaults to True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pd.DataFrame,np.ndarray]</span>
<span class="sd">            DataFrame or ndarray of attribute values in each column for request date range</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>

<span class="sd">        Pull two system attribute time series</span>

<span class="sd">        &gt;&gt;&gt; from swmm.pandas import Output,test_out_path</span>
<span class="sd">        &gt;&gt;&gt; out = Output(test_out_path)</span>
<span class="sd">        &gt;&gt;&gt; out.system_series(['total_lateral_inflow','rainfall'])</span>
<span class="sd">                            total_lateral_inflow  rainfall</span>
<span class="sd">        datetime</span>
<span class="sd">        1900-01-01 00:05:00              0.902807   0.03000</span>
<span class="sd">        1900-01-01 00:10:00              0.902800   0.03000</span>
<span class="sd">        1900-01-01 00:15:00              0.902793   0.03000</span>
<span class="sd">        1900-01-01 00:20:00              0.902786   0.03000</span>
<span class="sd">        1900-01-01 00:25:00              0.902779   0.03000</span>
<span class="sd">        ...                                   ...       ...</span>
<span class="sd">        1900-01-01 23:40:00              1.431874   0.03224</span>
<span class="sd">        1900-01-01 23:45:00              1.431869   0.03224</span>
<span class="sd">        1900-01-01 23:50:00              1.431876   0.03224</span>
<span class="sd">        1900-01-01 23:55:00              1.431894   0.03224</span>
<span class="sd">        1900-01-02 00:00:00              1.431921   0.00000</span>
<span class="sd">        [288 rows x 2 columns]</span>

<span class="sd">        """</span>

        <span class="n">attributeArray</span><span class="p">,</span> <span class="n">attributeIndexArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateAttribute</span><span class="p">(</span>
            <span class="n">attribute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_attributes</span>
        <span class="p">)</span>

        <span class="n">startIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">endIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_period</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">output</span><span class="o">.</span><span class="n">get_system_series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">sysAttr</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">endIndex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">sysAttr</span> <span class="ow">in</span> <span class="n">attributeIndexArray</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>

        <span class="n">dfIndex</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeIndex</span><span class="p">[</span><span class="n">startIndex</span><span class="p">:</span><span class="n">endIndex</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">"datetime"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dfIndex</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">attributeArray</span><span class="p">)</span></div>

    <span class="c1">####### attribute getters #######</span>

<div class="viewcode-block" id="Output.subcatch_attribute"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.subcatch_attribute.html#swmm.pandas.Output.subcatch_attribute">[docs]</a>    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">subcatch_attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="p">],</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">"rainfall"</span><span class="p">,</span>
            <span class="s2">"runoff_rate"</span><span class="p">,</span>
            <span class="s2">"gw_outflow_rate"</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">asframe</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">"""For all subcatchments at a given time, get a one or more attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : Union[str, int, datetime]</span>
<span class="sd">            The datetime or simulation index for which to pull data, defaults to None.</span>

<span class="sd">        attribute : Union[int, str, Enum, Sequence[Union[int, str, Enum]], None],</span>
<span class="sd">            The attribute index or name.</span>

<span class="sd">            On of:</span>

<span class="sd">            **rainfall, snow_depth, evap_loss, infil_loss, runoff_rate, gw_outflow_rate,</span>
<span class="sd">            gw_table_elev, soil_moisture**.</span>

<span class="sd">            Defaults to: `('rainfall','runoff_rate','gw_outflow_rate').`</span>

<span class="sd">            You can also input the integer index of the attribute you would like to</span>
<span class="sd">            pull or the actual enum from Output.subcatch_attributes.</span>

<span class="sd">            Setting to None indicates all attributes.</span>

<span class="sd">        asframe: bool</span>
<span class="sd">            A switch to return an indexed DataFrame. Set to False to get an array of values only, defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pd.DataFrame, np.ndarray]</span>
<span class="sd">            A DataFrame or ndarray of attribute values in each column for requested simulation time.</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>
<span class="sd">        Pull rainfall at start of simulation</span>

<span class="sd">        &gt;&gt;&gt; from swmm.pandas import Output,test_out_path</span>
<span class="sd">        &gt;&gt;&gt; out = Output(test_out_path)</span>
<span class="sd">        &gt;&gt;&gt; out.subcatch_attribute(0,'rainfall')</span>
<span class="sd">                          rainfall</span>
<span class="sd">            subcatchment</span>
<span class="sd">            SUB1              0.03</span>
<span class="sd">            SUB2              0.03</span>
<span class="sd">            SUB3              0.03</span>

<span class="sd">        Pull rainfall at middle of simulation</span>

<span class="sd">        &gt;&gt;&gt; out.subcatch_attribute(out.period/2,'rainfall')</span>
<span class="sd">                      rainfall</span>
<span class="sd">        subcatchment</span>
<span class="sd">        SUB1             1.212</span>
<span class="sd">        SUB2             1.212</span>
<span class="sd">        SUB3             1.212</span>


<span class="sd">        """</span>

        <span class="n">attributeArray</span><span class="p">,</span> <span class="n">attributeIndexArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateAttribute</span><span class="p">(</span>
            <span class="n">attribute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcatch_attributes</span>
        <span class="p">)</span>

        <span class="n">timeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">([</span><span class="n">time</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">output</span><span class="o">.</span><span class="n">get_subcatch_attribute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">timeIndex</span><span class="p">,</span> <span class="n">scAttr</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">scAttr</span> <span class="ow">in</span> <span class="n">attributeIndexArray</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>

        <span class="n">dfIndex</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subcatchments</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"subcatchment"</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dfIndex</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">attributeArray</span><span class="p">)</span></div>

<div class="viewcode-block" id="Output.node_attribute"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.node_attribute.html#swmm.pandas.Output.node_attribute">[docs]</a>    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">node_attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="p">],</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">"invert_depth"</span><span class="p">,</span>
            <span class="s2">"flooding_losses"</span><span class="p">,</span>
            <span class="s2">"total_inflow"</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">asframe</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">"""For all nodes at a given time, get one or more attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : Union[str, int, datetime]</span>
<span class="sd">            The datetime or simulation index for which to pull data, defaults to None</span>

<span class="sd">        attribute : Union[int, str, Enum, Sequence[Union[int, str, Enum]], None],</span>
<span class="sd">            The attribute index or name.</span>

<span class="sd">            On of:</span>

<span class="sd">            **invert_depth, hydraulic_head, ponded_volume, lateral_inflow,</span>
<span class="sd">            total_inflow, flooding_losses**.</span>

<span class="sd">            defaults to: `('invert_depth','flooding_losses','total_inflow')`</span>

<span class="sd">            Can also input the integer index of the attribute you would like to</span>
<span class="sd">            pull or the actual enum from Output.node_attributes.</span>

<span class="sd">            Setting to None indicates all attributes.</span>

<span class="sd">        asframe: bool</span>
<span class="sd">            A switch to return an indexed DataFrame. Set to False to get an array of values only, defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pd.DataFrame, np.ndarray]</span>
<span class="sd">            A DataFrame or ndarray of attribute values in each column for requested simulation time.</span>

<span class="sd">        """</span>
        <span class="n">attributeArray</span><span class="p">,</span> <span class="n">attributeIndexArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateAttribute</span><span class="p">(</span>
            <span class="n">attribute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span>
        <span class="p">)</span>

        <span class="n">timeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">([</span><span class="n">time</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">output</span><span class="o">.</span><span class="n">get_node_attribute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">timeIndex</span><span class="p">,</span> <span class="n">ndAttr</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ndAttr</span> <span class="ow">in</span> <span class="n">attributeIndexArray</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>

        <span class="n">dfIndex</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"node"</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dfIndex</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">attributeArray</span><span class="p">)</span></div>

<div class="viewcode-block" id="Output.link_attribute"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.link_attribute.html#swmm.pandas.Output.link_attribute">[docs]</a>    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">link_attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="p">],</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">"flow_rate"</span><span class="p">,</span>
            <span class="s2">"flow_velocity"</span><span class="p">,</span>
            <span class="s2">"flow_depth"</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">asframe</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">"""For all links at a given time, get one or more attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : Union[str, int, datetime]</span>
<span class="sd">            The datetime or simulation index for which to pull data, defaults to None.</span>

<span class="sd">        attribute : Union[int, str, Sequence[Union[int, str]], None]</span>
<span class="sd">            The attribute index or name.</span>

<span class="sd">            On of:</span>

<span class="sd">            flow_rate, flow_depth, flow_velocity, flow_volume, capacity,</span>

<span class="sd">            defaults to `('flow_rate','flow_velocity','flow_depth')`</span>

<span class="sd">            Can also input the integer index of the attribute you would like to</span>
<span class="sd">            pull or the actual enum from Output.link_attributes.</span>

<span class="sd">            Setting to None indicates all attributes.</span>

<span class="sd">        asframe: bool</span>
<span class="sd">            A switch to return an indexed DataFrame. Set to False to get an array of values only, defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            A DataFrame of attribute values in each column for requested simulation time.</span>

<span class="sd">        """</span>
        <span class="n">attributeArray</span><span class="p">,</span> <span class="n">attributeIndexArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateAttribute</span><span class="p">(</span>
            <span class="n">attribute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">link_attributes</span>
        <span class="p">)</span>

        <span class="n">timeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">([</span><span class="n">time</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">output</span><span class="o">.</span><span class="n">get_link_attribute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">timeIndex</span><span class="p">,</span> <span class="n">lnkAttr</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">lnkAttr</span> <span class="ow">in</span> <span class="n">attributeIndexArray</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>

        <span class="n">dfIndex</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"link"</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dfIndex</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">attributeArray</span><span class="p">)</span></div>

<div class="viewcode-block" id="Output.system_attribute"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.system_attribute.html#swmm.pandas.Output.system_attribute">[docs]</a>    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">system_attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="p">],</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">asframe</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">"""For all nodes at given time, get a one or more attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : Union[str, int, datetime]</span>
<span class="sd">            The datetime or simulation index for which to pull data, defaults to None.</span>

<span class="sd">        attribute : Union[int, str, Sequence[Union[int, str]], None]</span>
<span class="sd">            The attribute index or name.</span>

<span class="sd">            On of:</span>

<span class="sd">            **air_temp, rainfall, snow_depth, evap_infil_loss, runoff_flow,</span>
<span class="sd">            dry_weather_inflow, gw_inflow, rdii_inflow, direct_inflow, total_lateral_inflow,</span>
<span class="sd">            flood_losses, outfall_flows, volume_stored, evap_rate**.</span>

<span class="sd">            defaults to `None`.</span>

<span class="sd">            Can also input the integer index of the attribute you would like to</span>
<span class="sd">            pull or the actual enum from Output.system_attributes.</span>

<span class="sd">            Setting to None indicates all attributes.</span>

<span class="sd">        asframe: bool</span>
<span class="sd">            A switch to return an indexed DataFrame. Set to False to get an array of values only, defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pd.DataFrame,np.ndarray]</span>
<span class="sd">            A DataFrame of attribute values in each column for requested simulation time.</span>

<span class="sd">        """</span>

        <span class="n">attributeArray</span><span class="p">,</span> <span class="n">attributeIndexArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateAttribute</span><span class="p">(</span>
            <span class="n">attribute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_attributes</span>
        <span class="p">)</span>

        <span class="n">timeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">([</span><span class="n">time</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">output</span><span class="o">.</span><span class="n">get_system_attribute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">timeIndex</span><span class="p">,</span> <span class="n">sysAttr</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">sysAttr</span> <span class="ow">in</span> <span class="n">attributeIndexArray</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>

        <span class="n">dfIndex</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">attributeArray</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"attribute"</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dfIndex</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">"result"</span><span class="p">])</span></div>

    <span class="c1">####### result getters #######</span>

<div class="viewcode-block" id="Output.subcatch_result"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.subcatch_result.html#swmm.pandas.Output.subcatch_result">[docs]</a>    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">subcatch_result</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">subcatchment</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">asframe</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">"""For a subcatchment at one or more given times, get all attributes.</span>

<span class="sd">        Only one of `subcatchment` or `time` can be multiple (eg. a list), not both.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subcatchment : Union[int, str, Sequence[Union[int, str]], None],</span>
<span class="sd">            The subcatchment(s) name(s) or index(s).</span>

<span class="sd">        time: Union[int, str, Sequence[Union[int, str]], None],</span>
<span class="sd">            THe datetime(s) or simulation index(s).</span>

<span class="sd">        asframe: bool</span>
<span class="sd">            A switch to return an indexed DataFrame. Set to False to get an array of values only, defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pd.DataFrame,np.ndarray]</span>
<span class="sd">            A DataFrame or ndarray of all attribute values subcatchment(s) at given time(s).</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subcatchment</span><span class="p">,</span> <span class="n">arrayish</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">arrayish</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Can only have multiple of one of subcatchment and time"</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subcatchment</span><span class="p">,</span> <span class="n">arrayish</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">"subcatchment"</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateElement</span><span class="p">(</span><span class="n">subcatchment</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcatchments</span><span class="p">)</span>
            <span class="n">timeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">([</span><span class="n">time</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">values</span> <span class="o">=</span> <span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">get_subcatch_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">timeIndex</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">"datetime"</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeIndex</span> <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

            <span class="c1"># since the timeIndex matches on nearst, we rebuild</span>
            <span class="c1"># the label in case it wasn't exact</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeIndex</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">subcatchmentIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcatchmentIndex</span><span class="p">(</span><span class="n">subcatchment</span><span class="p">)</span>

            <span class="n">values</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span>
                <span class="n">vstack</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">output</span><span class="o">.</span><span class="n">get_subcatch_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">subcatchmentIndex</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>

        <span class="n">dfIndex</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dfIndex</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">_enum_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subcatch_attributes</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Output.node_result"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.node_result.html#swmm.pandas.Output.node_result">[docs]</a>    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">node_result</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">asframe</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">"""For one or more nodes at one or more given times, get all attributes.</span>

<span class="sd">        Only one of `node` or `time` can be multiple (eg. a list), not both.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : Union[int, str, Sequence[Union[int, str]], None],</span>
<span class="sd">            The node(s) name(s) or index(s).</span>

<span class="sd">        time: Union[int, str, Sequence[Union[int, str]], None],</span>
<span class="sd">            The datetime(s) or simulation index(s).</span>

<span class="sd">        asframe: bool</span>
<span class="sd">            A switch to return an indexed DataFrame. Set to False to get an array of values only, defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pd.DataFrame,np.ndarray]</span>
<span class="sd">            A DataFrame or ndarray of all attribute values nodes(s) at given time(s).</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">arrayish</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">arrayish</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Can only have multiple of one of node and time"</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">arrayish</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">"node"</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateElement</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">timeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">([</span><span class="n">time</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">get_node_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">timeIndex</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">"datetime"</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeIndex</span> <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

            <span class="c1"># since the timeIndex matches on nearst, we rebuild</span>
            <span class="c1"># the label in case it wasn't exact</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeIndex</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">nodeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodeIndex</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="n">values</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span>
                <span class="n">vstack</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">output</span><span class="o">.</span><span class="n">get_node_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">nodeIndex</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>

        <span class="n">dfIndex</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dfIndex</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">_enum_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Output.link_result"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.link_result.html#swmm.pandas.Output.link_result">[docs]</a>    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">link_result</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">link</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">asframe</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">"""For a link at one or more given times, get all attributes.</span>

<span class="sd">        Only one of link or time can be multiple.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        link : Union[int, str, Sequence[Union[int, str]], None],</span>
<span class="sd">            The link(s) name(s) or index(s).</span>

<span class="sd">        time: Union[int, str, Sequence[Union[int, str]], None],</span>
<span class="sd">            The datetime(s) or simulation index(s).</span>

<span class="sd">        asframe: bool</span>
<span class="sd">            A switch to return an indexed DataFrame. Set to False to get an array of values only, defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pd.DataFrame,np.ndarray]</span>
<span class="sd">            A DataFrame or ndarray of all attribute values link(s) at given time(s).</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">arrayish</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">arrayish</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Can only have multiple of one of link and time"</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">arrayish</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">"link"</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validateElement</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>
            <span class="n">timeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">([</span><span class="n">time</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">values</span> <span class="o">=</span> <span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">get_link_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">timeIndex</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">"datetime"</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeIndex</span> <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

            <span class="c1"># since the timeIndex matches on nearst, we rebuild</span>
            <span class="c1"># the label in case it wasn't exact</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeIndex</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

            <span class="n">linkIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linkIndex</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span>
                <span class="n">vstack</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">output</span><span class="o">.</span><span class="n">get_link_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">linkIndex</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>

        <span class="n">dfIndex</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dfIndex</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">_enum_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link_attributes</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Output.system_result"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.system_result.html#swmm.pandas.Output.system_result">[docs]</a>    <span class="nd">@output_open_handler</span>
    <span class="k">def</span> <span class="nf">system_result</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="p">],</span>
        <span class="n">asframe</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">"""For a given time, get all system attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : Union[str, int, datetime]</span>
<span class="sd">            The datetime or simulation index.</span>

<span class="sd">        asframe: bool</span>
<span class="sd">            A switch to return an indexed DataFrame. Set to False to get an array of values only, defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pd.DataFrame,np.ndarray]</span>
<span class="sd">            A DataFrame of attribute values in each row for requested simulation time.</span>

<span class="sd">        """</span>

        <span class="n">timeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time2step</span><span class="p">([</span><span class="n">time</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">get_system_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span> <span class="n">timeIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>

        <span class="n">dfIndex</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">_enum_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">system_attributes</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">"attribute"</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dfIndex</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">"Result"</span><span class="p">])</span></div>

<div class="viewcode-block" id="Output.getStructure"><a class="viewcode-back" href="../../../../reference/output/api/swmm.pandas.Output.getStructure.html#swmm.pandas.Output.getStructure">[docs]</a>    <span class="k">def</span> <span class="nf">getStructure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a structure object for a given list of links and nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        link : Union[str, Sequence[str]]</span>
<span class="sd">            The list of links that belong to the structure.</span>
<span class="sd">        node : Union[str, Sequence[str]]</span>
<span class="sd">            The list of nodes that below to the structure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Structure</span>
<span class="sd">            Structure comprised of the given links and nodes.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span></div>

    <span class="c1"># close outfile when object deleted</span>
    <span class="c1"># this doesn't always get called on sys.exit()</span>
    <span class="c1"># better to use output object with context</span>
    <span class="c1"># manager to ensure _open() and _close() are always closed</span>
    <span class="c1"># in some cases, you can get a memory leak message from swig:</span>
    <span class="c1"># &gt;&gt;&gt; exit()</span>
    <span class="c1"># swig/python detected a memory leak of type 'struct Handle *', no destructor found.</span>
    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        Destructor for outfile handle</span>

<span class="sd">        :return: Nothing</span>
<span class="sd">        :rtype: NoReturn</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">()</span>

    <span class="c1"># method used for context manager with statement</span>
    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># method used for context manager with statement</span>
    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">()</span></div>
</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2021, Constantine Karos.
              
          </div>
            Last updated on
              Mar 31, 2022.
            <br/>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>